using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace FFTW.NET
{
    /// <summary>
    /// Contains logic that was for some reason originally hardcoded into an autogenerated file
    /// </summary>
    public static partial class FftwInterop
    {
        static readonly Version _version = GetVersionAndInitialize();
        public static Version Version => _version;
        public static bool IsAvailable => _version != null;

        internal static object Lock
        {
            get
            {
                if (!IsAvailable)
                    throw new InvalidOperationException($"{nameof(FftwInterop.IsAvailable)} is false.");
                return _version;
            }
        }

        public delegate void WriteCharHandler(byte c, IntPtr ptr);

        static Version GetVersionAndInitialize()
        {
            try { fftw_init_threads(); }
            catch (DllNotFoundException) { return null; }
            string version = GetVersion();
            return new Version(version);
        }

        public static string fftw_export_wisdom_to_string()
        {
            // We cannot use the fftw_export_wisdom_to_string function here
            // because we have no way of releasing the returned memory.
            StringBuilder sb = new StringBuilder();
            FftwInterop.WriteCharHandler writeChar = (c, ptr) => sb.Append((char)c);
            FftwInterop.fftw_export_wisdom(writeChar, IntPtr.Zero);
            return sb.ToString();
        }

        static string GetVersion()
        {
            const string VersionPrefix = "fftw-";
            const byte WhiteSpace = (byte)' ';
            byte[] prefix = Encoding.ASCII.GetBytes(VersionPrefix);
            int i = 0;
            StringBuilder sb = new StringBuilder();
            FftwInterop.WriteCharHandler writeChar = (c, ptr) =>
            {
                if (i < 0)
                    return;
                if (i == VersionPrefix.Length)
                {
                    if (c == WhiteSpace)
                        i = -1;
                    else
                        sb.Append((char)c);
                }
                else if (c == prefix[i])
                    i++;
                else
                    i = 0;
            };
            // This is only called on initialization, so no synchronization/lock is required
            FftwInterop.fftw_export_wisdom(writeChar, IntPtr.Zero);
            Console.WriteLine($"Version is {sb.ToString()}");
            return sb.ToString();
        }
    }
}
